---
키워드: 1주차 생각
---

- 제너레이터는 젤루 멋진 이터러블이터레이터

  ```ts
  const iterable0: Iterable<string> = '123';
  const iterable1: Iterable<number> = [1, 2, 3];
  const iterable2: Iterable<number> = new Set([1, 2, 3]);
  const iterable3: Iterable<[string, number]> = new Map([
    ['a', 1],
    ['b', 2],
    ['c', 3],
  ]);

  const iterable4: Iterable<number> = {
    [Symbol.iterator]: function* () {
      yield 1;
      yield 2;
      yield 3;
    },
  };
  console.log([...iterable3]);
  for (const x of iterable3) console.log(x);

  const iterable5: Iterable<number> = {
    [Symbol.iterator]: function () {
      let i = 1;
      return {
        next: () => ({ value: i++, done: i > 4 }),
      };
    },
  };
  console.log([...iterable5]);
  for (const x of iterable5) console.log(x);
  ```

- 다형성이 뭘 말한걸까
  ## 객체지향의 다형성과 함수형 프로그래밍에 입각한 map구현이 갖는 다형성의 차이
  객체지향과 함수형 프로그래밍에서 사용하는 "다형성"이라는 개념은 서로 다른 맥락에서 사용되지만, 근본적인 목적과 일부 특성에서 공통점을 가집니다.
  공통점:
  1.  추상화:
      두 패러다임 모두 다형성을 통해 코드의 추상화 수준을 높입니다. 이는 구체적인 구현 세부사항을 숨기고 더 일반화된 인터페이스를 제공합니다.
      코드 재사용:
      다형성은 두 경우 모두 코드 재사용성을 증가시킵니다. 동일한 인터페이스나 함수를 여러 타입이나 데이터 구조에 적용할 수 있게 합니다.
  2.  유연성:
      다양한 타입이나 데이터 구조를 동일한 방식으로 다룰 수 있게 해주어 코드의 유연성을 높입니다.
  3.  확장성:
      새로운 타입이나 데이터 구조를 기존 시스템에 쉽게 통합할 수 있게 해줍니다.
  4.  타입 안정성:
      컴파일 시간에 타입 체크를 통해 안정성을 제공합니다.
      주요 차이점:
      구현 방식:
      객체지향: 클래스 계층구조, 인터페이스, 메서드 오버라이딩을 통해 구현
      함수형: 고차 함수, 제네릭 프로그래밍, 이터러블 프로토콜 등을 통해 구현
      중점사항:
      객체지향: 객체의 행위에 초점
      함수형: 데이터 변환과 연산에 초점
      확장 방법:
      객체지향: 새로운 클래스나 인터페이스 추가
      함수형: 기존 함수를 새로운 데이터 구조에 적용
      결론적으로, "다형성"이라는 용어는 두 패러다임에서 같은 단어를 사용하지만, 그 구현 방식과 접근 방법에서 차이를 보입니다. 그러나 근본적으로 코드의 재사용성, 유연성, 확장성을 높이고자 하는 목적은 동일합니다. 두 접근 방식 모두 프로그래밍의 핵심 원칙인 "추상화"를 달성하는 방법으로 다형성을 활용한다고 볼 수 있습니다.
